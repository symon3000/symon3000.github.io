<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draggable To-Do Cards</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #e0e0e0;
        }

        #canvas {
            width: 100%;
            height: 100vh;
            background-color: #1e1e1e;
            border: none;
            position: relative;
            overflow: auto;
        }

        .card {
            width: 200px;
            min-height: 100px;
            background-color: #2c2c2c;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 10px;
            position: absolute;
            cursor: move;
            user-select: none;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            color: #e0e0e0;
            z-index: 10;
        }

        .delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            cursor: pointer;
            font-weight: bold;
            color: #ff6b6b;
        }

        .card.selected {
            box-shadow: 0 0 0 2px #4CAF50;
        }

        #selection-box {
            position: absolute;
            border: 2px dashed #4CAF50;
            background-color: rgba(76, 175, 80, 0.1);
            pointer-events: none;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 400px;
            background-color: #2c2c2c;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .modal-content {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        .close-modal {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
            cursor: pointer;
            color: #e0e0e0;
        }

        .close-modal:hover {
            color: #ffffff;
        }

        #batchInput {
            width: 100%;
            height: 100%;
            border: none;
            resize: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        .card-text {
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
            max-width: 100%;
        }

        .header {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
            cursor: move;
            user-select: none;
            padding: 10px;
            z-index: 20;
        }

        .header .delete-btn {
            font-size: 16px;
            visibility: hidden;
        }

        .header:hover .delete-btn {
            visibility: visible;
        }

        .minimize-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            color: #e0e0e0;
        }

        .agenda.minimized .time-slot {
            display: none;
        }

        /* Agenda Styles */
        .agenda {
            position: absolute;
            width: 300px;
            background-color: #2c2c2c;
            border: 1px solid #444;
            border-radius: 5px;
            cursor: move;
            user-select: none;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            color: #e0e0e0;
            z-index: 5;
        }

        .agenda-header {
            background-color: #3c3c3c;
            padding: 10px;
            font-weight: bold;
            text-align: center;
            border-bottom: 1px solid #444;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
        }

        .time-slot {
            padding: 10px;
            border-bottom: 1px solid #444;
            min-height: 30px;
            display: flex;
        }

        .time-label {
            width: 60px;
        }

        .slot-content {
            flex-grow: 1;
            min-height: 20px;
        }

        .card-in-slot {
            width: auto;
            min-height: auto;
            position: relative;
            margin-bottom: 5px;
            padding: 5px;
            background-color: #3e3e3e;
            border-radius: 3px;
        }
    </style>
</head>

<body>
    <div id="canvas">
        <div id="batchModal" class="modal">
            <div class="modal-content">
                <span class="close-modal">&times;</span>
                <textarea id="batchInput" placeholder="One task per line, cmd+enter when done"></textarea>
            </div>
        </div>
    </div>

    <script>
        const todos = [
            "double-click to edit\n\ncmd+enter to add\n\ncmd+shift+enter to batch\n\ncmd+A to select all\n\ncmd+delete to remove\n\ncmd+shift+H for header"
        ];

        const canvas = document.getElementById('canvas');
        let activeCard = null;
        let initialX, initialY;
        let isEditing = false;
        let isSelecting = false;
        let selectionStart = {x: 0, y: 0};
        let selectionBox = null;
        let selectedCards = new Set();
        let activeAgenda = null;
        let draggedItem = null;
        let overSlot = null;
        let draggedFromAgenda = false;
        let originalParent = null;
        let originalPosition = { left: 0, top: 0 };

        let lastCardPosition = {col: 0, row: 0};
        const cardWidth = 220;  // 200px width + 20px margin
        const cardHeight = 120; // 100px height + 20px margin

        const batchModal = document.getElementById('batchModal');
        const batchInput = document.getElementById('batchInput');
        const closeModalBtn = document.querySelector('.close-modal');
        let isBatchModalOpen = false;

        // Initialize lastCardPosition based on existing cards
        function initializeLastCardPosition() {
            const cards = document.querySelectorAll('.card');
            if (cards.length > 0) {
                const firstCard = cards[0];
                const col = Math.floor((parseInt(firstCard.style.left) - initialXOffset) / cardWidth);
                const row = Math.floor((parseInt(firstCard.style.top) - initialYOffset) / cardHeight);
                lastCardPosition.col = col;
                lastCardPosition.row = row + 1;
            }
        }

        function createCard(text = '', x = 0, y = 0) {
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `
                <span class="delete-btn">&times;</span>
                <p class="card-text">${text}</p>
            `;
            card.style.left = `${x}px`;
            card.style.top = `${y}px`;
            // Start with draggable=false to avoid conflicts
            card.draggable = false;

            const deleteBtn = card.querySelector('.delete-btn');
            deleteBtn.addEventListener('click', () => {
                canvas.removeChild(card);
            });

            const cardText = card.querySelector('.card-text');
            cardText.addEventListener('dblclick', () => {
                isEditing = true;
                cardText.contentEditable = true;
                cardText.focus();
            });

            cardText.addEventListener('blur', () => {
                isEditing = false;
                cardText.contentEditable = false;
            });

            card.addEventListener('mousedown', startDragging);
            canvas.appendChild(card);

            // Focus on the text and make it editable immediately for new cards
            if (text === 'New Todo') {
                isEditing = true;
                cardText.contentEditable = true;
                cardText.focus();
                // Select all text
                window.getSelection().selectAllChildren(cardText);
            }

            return card;
        }

        function createAgenda() {
            const agenda = document.createElement('div');
            agenda.className = 'agenda';
            agenda.innerHTML = `
                <div class="agenda-header">
                    <span>drag cards here</span>
                    <span class="minimize-btn">−</span>
                </div>
            `;
            // Position the agenda on the left side of the canvas
            agenda.style.left = '30px';
            agenda.style.top = '30px';

            // Add time slots from 7AM to 9PM
            for (let hour = 7; hour <= 21; hour++) {
                const formattedHour = hour >= 12 ? (hour > 12 ? (hour - 12) : hour) + ' PM' : hour + ' AM';
                const timeSlot = document.createElement('div');
                timeSlot.className = 'time-slot';
                timeSlot.dataset.hour = hour;
                timeSlot.innerHTML = `
                    <div class="time-label">${formattedHour}</div>
                    <div class="slot-content" data-hour="${hour}"></div>
                `;
                agenda.appendChild(timeSlot);

                // Make the slot-content a drop target
                const slotContent = timeSlot.querySelector('.slot-content');
                slotContent.addEventListener('dragover', handleSlotDragOver);
                slotContent.addEventListener('dragleave', handleSlotDragLeave);
                slotContent.addEventListener('drop', handleSlotDrop);
                slotContent.addEventListener('dblclick', (e) => {
                    if (e.target === slotContent) {
                        const cardInSlot = document.createElement('div');
                        cardInSlot.className = 'card-in-slot';
                        cardInSlot.draggable = true;
                        cardInSlot.innerHTML = `
                            <span class="delete-btn">&times;</span>
                            <div class="card-text">New Task</div>
                        `;

                        const deleteBtn = cardInSlot.querySelector('.delete-btn');
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            cardInSlot.remove();
                        });

                        const cardTextElement = cardInSlot.querySelector('.card-text');
                        cardTextElement.addEventListener('dblclick', (e) => {
                            e.stopPropagation();
                            cardTextElement.contentEditable = true;
                            cardTextElement.focus();
                        });

                        cardTextElement.addEventListener('blur', () => {
                            cardTextElement.contentEditable = false;
                        });

                        cardInSlot.addEventListener('dragstart', handleCardInAgendaDrag);
                        cardInSlot.addEventListener('dragend', handleCardInAgendaDragEnd);

                        slotContent.appendChild(cardInSlot);
                        
                        // Make the text editable immediately
                        cardTextElement.contentEditable = true;
                        cardTextElement.focus();
                        window.getSelection().selectAllChildren(cardTextElement);
                    }
                });

                // Enable dragging into and out of slots
                slotContent.addEventListener('dragstart', function(e) {
                    if (e.target.classList.contains('card-in-slot')) {
                        draggedItem = e.target;
                        draggedFromAgenda = true;
                        originalParent = slotContent;
                        // Store original position for returning to canvas if needed
                        const agendaRect = slotContent.closest('.agenda').getBoundingClientRect();
                        originalPosition = {
                            left: agendaRect.left + 50,
                            top: slotContent.getBoundingClientRect().top
                        };
                        setTimeout(() => {
                            draggedItem.style.opacity = '0.5';
                        }, 0);
                    }
                });
            }

            // Add minimize button functionality
            const minimizeBtn = agenda.querySelector('.minimize-btn');
            minimizeBtn.addEventListener('click', () => {
                agenda.classList.toggle('minimized');
                minimizeBtn.textContent = agenda.classList.contains('minimized') ? '+' : '−';
            });

            // Make agenda draggable
            agenda.addEventListener('mousedown', (e) => {
                // Only handle drag if it's on the header or the time labels
                if (e.target.closest('.agenda-header') || e.target.classList.contains('time-label')) {
                    activeAgenda = agenda;
                    initialX = e.clientX - agenda.offsetLeft;
                    initialY = e.clientY - agenda.offsetTop;

                    document.addEventListener('mousemove', dragAgenda);
                    document.addEventListener('mouseup', stopDraggingAgenda);
                }

                // Prevent propagation to canvas to avoid selection box
                e.stopPropagation();
            });

            canvas.appendChild(agenda);
            return agenda;
        }

        function dragAgenda(e) {
            if (activeAgenda) {
                e.preventDefault();
                let newX = e.clientX - initialX;
                let newY = e.clientY - initialY;

                newX += canvas.scrollLeft;
                newY += canvas.scrollTop;

                // Boundary check
                newX = Math.max(0, newX);
                newY = Math.max(0, newY);

                activeAgenda.style.left = `${newX}px`;
                activeAgenda.style.top = `${newY}px`;
            }
        }

        function stopDraggingAgenda() {
            activeAgenda = null;
            document.removeEventListener('mousemove', dragAgenda);
            document.removeEventListener('mouseup', stopDraggingAgenda);
        }

        function handleCardInAgendaDrag(e) {
            draggedItem = e.currentTarget;
            draggedFromAgenda = true;
            originalParent = draggedItem.parentNode;

            // Store original position for returning to canvas
            if (originalParent.classList.contains('slot-content')) {
                const agendaRect = originalParent.closest('.agenda').getBoundingClientRect();
                originalPosition = {
                    left: agendaRect.left + 50,
                    top: originalParent.getBoundingClientRect().top
                };
            }

            // Add a placeholder
            const placeholder = document.createElement('div');
            placeholder.className = 'card-placeholder';
            placeholder.style.height = `${draggedItem.offsetHeight}px`;
            originalParent.appendChild(placeholder);

            // Set drag effect
            draggedItem.style.opacity = '0.5';
            setTimeout(() => {
                if (draggedFromAgenda) {
                    draggedItem.style.pointerEvents = 'none';
                }
            }, 0);
        }

        function handleCardInAgendaDragEnd() {
            if (draggedItem) {
                draggedItem.style.opacity = '1';
                draggedItem.style.pointerEvents = 'auto';

                // Remove any placeholders
                document.querySelectorAll('.card-placeholder').forEach(el => el.remove());

                draggedItem = null;
                draggedFromAgenda = false;
                overSlot = null;
            }
        }

        function handleSlotDragOver(e) {
            e.preventDefault();
            overSlot = e.currentTarget;
            overSlot.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
        }

        function handleSlotDragLeave(e) {
            if (overSlot === e.currentTarget) {
                overSlot.style.backgroundColor = '';
                overSlot = null;
            }
        }

        function handleSlotDrop(e) {
            e.preventDefault();
            if (overSlot) {
                overSlot.style.backgroundColor = '';

                if (draggedItem) {
                    // Convert regular card to in-slot card
                    const cardText = draggedItem.querySelector('.card-text').textContent;
                    const cardInSlot = document.createElement('div');
                    cardInSlot.className = 'card-in-slot';
                    cardInSlot.draggable = true;
                    cardInSlot.innerHTML = `
                        <span class="delete-btn">&times;</span>
                        <div class="card-text">${cardText}</div>
                    `;

                    // Add delete functionality
                    const deleteBtn = cardInSlot.querySelector('.delete-btn');
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        cardInSlot.remove();
                    });

                    // Make card draggable from slot
                    // Add double-click editing
                    const cardTextElement = cardInSlot.querySelector('.card-text');
                    cardTextElement.addEventListener('dblclick', () => {
                        cardTextElement.contentEditable = true;
                        cardTextElement.focus();
                    });

                    cardTextElement.addEventListener('blur', () => {
                        cardTextElement.contentEditable = false;
                    });

                    cardInSlot.addEventListener('dragstart', handleCardInAgendaDrag);
                    cardInSlot.addEventListener('dragend', handleCardInAgendaDragEnd);

                    overSlot.appendChild(cardInSlot);

                    // If we dragged from canvas, remove the original card
                    if (!draggedFromAgenda && draggedItem.parentNode === canvas) {
                        canvas.removeChild(draggedItem);
                    }

                    // Remove original card regardless of whether it's from the same slot or another slot
                    if (draggedFromAgenda) {
                        originalParent.querySelectorAll('.card-placeholder').forEach(el => el.remove());
                        if (draggedItem.parentNode) {
                            draggedItem.parentNode.removeChild(draggedItem);
                        }
                    }
                }

                draggedItem = null;
                overSlot = null;
                draggedFromAgenda = false;
            }
        }

        // Function to handle dragging a card-in-slot out of the agenda
        function handleCardDragOut(e) {
            if (draggedFromAgenda && !overSlot) {
                // Create a new regular card based on the agenda card
                const cardText = draggedItem.querySelector('.card-text').textContent;

                // Calculate position based on where it was dropped
                const canvasRect = canvas.getBoundingClientRect();
                const dropX = e.clientX - canvasRect.left + canvas.scrollLeft;
                const dropY = e.clientY - canvasRect.top + canvas.scrollTop;

                const newCard = createCard(cardText, dropX - 100, dropY - 50);

                // Make it draggable
                newCard.draggable = true;
                newCard.addEventListener('dragstart', (e) => {
                    draggedItem = newCard;
                    e.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => {
                        newCard.style.opacity = '0.5';
                    }, 0);
                });

                newCard.addEventListener('dragend', (e) => {
                    newCard.style.opacity = '1';
                    handleCardDragOut(e);
                    draggedItem = null;
                });

                // Remove the original card from the agenda
                if (originalParent && draggedItem.parentNode) {
                    draggedItem.parentNode.removeChild(draggedItem);
                }

                draggedFromAgenda = false;
            }
        }

        function makeDraggable() {
            // Get all cards that don't already have drag event listeners
            const cards = document.querySelectorAll('.card:not([data-draggable="true"])');
            cards.forEach(card => {
                card.setAttribute('data-draggable', 'true');

                // We'll use a single mousedown/mousemove approach instead of 
                // switching between draggable modes
                card.draggable = false;

                card.addEventListener('mousedown', (e) => {
                    if (isEditing) return;

                    // Store reference to the card for both canvas and agenda operations
                    draggedItem = card;
                    activeCard = card;
                    draggedFromAgenda = false;

                    initialX = e.clientX - card.offsetLeft;
                    initialY = e.clientY - card.offsetTop;

                    // For selection handling
                    if (!card.classList.contains('selected')) {
                        selectedCards.forEach(c => c.classList.remove('selected'));
                        selectedCards.clear();
                        card.classList.add('selected');
                        selectedCards.add(card);
                    }

                    // We don't need a clone anymore, just use the actual card

                    // Custom drag handling
                    const dragMove = (moveEvent) => {
                        // Update standard canvas dragging
                        let newX = moveEvent.clientX - initialX;
                        let newY = moveEvent.clientY - initialY;

                        newX += canvas.scrollLeft;
                        newY += canvas.scrollTop;

                        const deltaX = newX - parseInt(activeCard.style.left);
                        const deltaY = newY - parseInt(activeCard.style.top);

                        selectedCards.forEach(card => {
                            const cardX = parseInt(card.style.left) + deltaX;
                            const cardY = parseInt(card.style.top) + deltaY;
                            card.style.left = `${cardX}px`;
                            card.style.top = `${cardY}px`;
                        });

                        // No clone to position anymore

                        // Check if we're over an agenda slot
                        const slots = document.querySelectorAll('.slot-content');
                        let isOverSlot = false;

                        slots.forEach(slot => {
                            const slotRect = slot.getBoundingClientRect();
                            if (moveEvent.clientX >= slotRect.left && moveEvent.clientX <= slotRect.right &&
                                moveEvent.clientY >= slotRect.top && moveEvent.clientY <= slotRect.bottom) {

                                // Highlight the slot
                                if (overSlot && overSlot !== slot) {
                                    overSlot.style.backgroundColor = '';
                                }
                                overSlot = slot;
                                overSlot.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
                                isOverSlot = true;
                            }
                        });

                        // Clear highlight if not over any slot
                        if (!isOverSlot && overSlot) {
                            overSlot.style.backgroundColor = '';
                            overSlot = null;
                        }
                    };

                    const dragEnd = () => {
                        // No clone to clean up

                        // Handle drop into agenda slot
                        if (overSlot) {
                            // Create in-slot card
                            const cardText = draggedItem.querySelector('.card-text').textContent;
                            const cardInSlot = document.createElement('div');
                            cardInSlot.className = 'card-in-slot';
                            cardInSlot.draggable = true;
                            cardInSlot.innerHTML = `
                                <span class="delete-btn">&times;</span>
                                <div class="card-text">${cardText}</div>
                            `;

                            // Add delete functionality
                            const deleteBtn = cardInSlot.querySelector('.delete-btn');
                            deleteBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                cardInSlot.remove();
                            });

                            // Add double-click editing
                            const cardTextElement = cardInSlot.querySelector('.card-text');
                            cardTextElement.addEventListener('dblclick', () => {
                                cardTextElement.contentEditable = true;
                                cardTextElement.focus();
                            });

                            cardTextElement.addEventListener('blur', () => {
                                cardTextElement.contentEditable = false;
                            });

                            // Add drag from slot functionality
                            cardInSlot.addEventListener('dragstart', handleCardInAgendaDrag);
                            cardInSlot.addEventListener('dragend', handleCardInAgendaDragEnd);

                            overSlot.appendChild(cardInSlot);

                            // Remove original card from canvas if it's not part of a multi-selection
                            if (selectedCards.size <= 1) {
                                canvas.removeChild(draggedItem);
                            } else {
                                // Just remove the active card from selection
                                selectedCards.delete(draggedItem);
                                canvas.removeChild(draggedItem);
                            }

                            overSlot.style.backgroundColor = '';
                            overSlot = null;
                        }

                        document.removeEventListener('mousemove', dragMove);
                        document.removeEventListener('mouseup', dragEnd);
                        activeCard = null;
                        draggedItem = null;
                    };

                    document.addEventListener('mousemove', dragMove);
                    document.addEventListener('mouseup', dragEnd);

                    // Prevent default dragging behavior
                    e.preventDefault();
                    e.stopPropagation();
                });

                // Keep these for dragging from agenda back to canvas
                card.addEventListener('dragend', (e) => {
                    card.style.opacity = '1';
                    handleCardDragOut(e);
                    draggedItem = null;
                });
            });

            // Make agenda slots droppable
            document.querySelectorAll('.slot-content').forEach(slot => {
                slot.addEventListener('dragover', handleSlotDragOver);
                slot.addEventListener('dragleave', handleSlotDragLeave);
                slot.addEventListener('drop', handleSlotDrop);
            });
        }

        // Position first card next to agenda (agenda is 300px wide + 30px margin) and align with agenda's top
        const initialXOffset = 360;
        const initialYOffset = 30; // Match agenda's top position
        todos.forEach((todo, index) => {
            createCard(todo, initialXOffset + (index % 4) * 220, initialYOffset + Math.floor(index / 4) * 120);
        });

        // Create an agenda
        createAgenda();

        // Make cards draggable
        makeDraggable();

        // Activate the input field of the first card
        const firstCard = document.querySelector('.card');
        if (firstCard) {
            const cardText = firstCard.querySelector('.card-text');
            isEditing = true;
            cardText.contentEditable = true;
            cardText.focus();
            // Select all text
            window.getSelection().selectAllChildren(cardText);
        }


        // Add this before your other event listeners
        window.addEventListener('keydown', (e) => {
            if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'h') {
                e.preventDefault();
                e.stopPropagation();
                createHeader();
                return false;
            }
        }, {capture: true, passive: false});  // The 'true' here makes this capture the event before other handlers

        document.addEventListener('keydown', (e) => {
            // Handle cmd+shift+enter first
            if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'Enter') {
                e.preventDefault();
                openBatchModal();
                return;
            }

            // Then handle cmd+enter
            if ((e.metaKey || e.ctrlKey) && !e.shiftKey && e.key === 'Enter') {
                e.preventDefault();
                if (isBatchModalOpen) {
                    createBatchCards();
                } else {
                    createNewCard();
                }
                return;
            }

            // Add this new block to handle cmd+a (or ctrl+a)
            if ((e.metaKey || e.ctrlKey) && e.key === 'a') {
                const activeElement = document.activeElement;
                const isEditing = activeElement.isContentEditable || 
                                activeElement.tagName === 'TEXTAREA' || 
                                activeElement.tagName === 'INPUT';
                
                if (!isEditing) {
                    e.preventDefault();
                    selectAllCards();
                }
            }

            // Update this block to handle Escape key and cmd+delete
            if (e.key === 'Escape' || ((e.metaKey || e.ctrlKey) && e.key === 'Backspace')) {
                const activeElement = document.activeElement;
                if (activeElement.classList.contains('card-text') && activeElement.isContentEditable) {
                    e.preventDefault();
                    if (e.key === 'Escape') {
                        activeElement.blur();
                        isEditing = false;
                        activeElement.contentEditable = false;
                    } else {
                        // Handle cmd+delete
                        const card = activeElement.closest('.card');
                        if (card) {
                            canvas.removeChild(card);
                            selectedCards.delete(card);
                        }
                    }
                } else if ((e.metaKey || e.ctrlKey) && e.key === 'Backspace') {
                    e.preventDefault();
                    deleteSelectedCards();
                }
            }

            // Add this new block to handle Escape key
            if (e.key === 'Escape') {
                if (isBatchModalOpen) {
                    closeBatchModal();
                } else {
                    const activeElement = document.activeElement;
                    if (activeElement.classList.contains('card-text') && activeElement.isContentEditable) {
                        activeElement.blur();
                        isEditing = false;
                        activeElement.contentEditable = false;
                    }
                }
            }

        });

        closeModalBtn.addEventListener('click', closeBatchModal);

        function createNewCard(text = '') {
            const initialXOffset = 360; // Same offset as initial cards
            const x = initialXOffset + lastCardPosition.col * cardWidth;
            const y = lastCardPosition.row * cardHeight;
            const card = createCard(text || 'New Todo', x, y);

            // Delegate draggable behavior to makeDraggable
            // Don't set draggable=true here

            // Update the last card position
            lastCardPosition.row++;
            if (lastCardPosition.row * cardHeight + cardHeight > canvas.clientHeight) {
                lastCardPosition.row = 0;
                lastCardPosition.col++;
            }

            // Call makeDraggable to set up the conditional drag behavior
            makeDraggable();
        }

        // Call this after creating initial cards
        initializeLastCardPosition();

        canvas.addEventListener('mousedown', startSelection);
        canvas.addEventListener('mousemove', updateSelection);
        canvas.addEventListener('mouseup', endSelection);

        function startSelection(e) {
            if (e.target === canvas) {
                isSelecting = true;
                const canvasRect = canvas.getBoundingClientRect();
                selectionStart = {
                    x: e.clientX - canvasRect.left + canvas.scrollLeft,
                    y: e.clientY - canvasRect.top + canvas.scrollTop
                };
                selectionBox = document.createElement('div');
                selectionBox.id = 'selection-box';
                canvas.appendChild(selectionBox);
            }
        }

        function updateSelection(e) {
            if (isSelecting) {
                const canvasRect = canvas.getBoundingClientRect();
                const currentX = e.clientX - canvasRect.left + canvas.scrollLeft;
                const currentY = e.clientY - canvasRect.top + canvas.scrollTop;
                const left = Math.min(selectionStart.x, currentX);
                const top = Math.min(selectionStart.y, currentY);
                const width = Math.abs(currentX - selectionStart.x);
                const height = Math.abs(currentY - selectionStart.y);

                selectionBox.style.left = `${left}px`;
                selectionBox.style.top = `${top}px`;
                selectionBox.style.width = `${width}px`;
                selectionBox.style.height = `${height}px`;

                // Check which cards are within the selection box
                document.querySelectorAll('.card').forEach(card => {
                    const rect = card.getBoundingClientRect();
                    const cardLeft = rect.left - canvasRect.left + canvas.scrollLeft;
                    const cardTop = rect.top - canvasRect.top + canvas.scrollTop;
                    if (cardLeft < left + width && cardLeft + rect.width > left &&
                        cardTop < top + height && cardTop + rect.height > top) {
                        card.classList.add('selected');
                        selectedCards.add(card);
                    } else {
                        card.classList.remove('selected');
                        selectedCards.delete(card);
                    }
                });
            }
        }

        function endSelection() {
            isSelecting = false;
            if (selectionBox) {
                canvas.removeChild(selectionBox);
                selectionBox = null;
            }
        }

        function startDragging(e) {
            if (isEditing) return;
            activeCard = e.currentTarget;
            initialX = e.clientX - activeCard.offsetLeft;
            initialY = e.clientY - activeCard.offsetTop;

            if (!activeCard.classList.contains('selected')) {
                selectedCards.forEach(card => card.classList.remove('selected'));
                selectedCards.clear();
                activeCard.classList.add('selected');
                selectedCards.add(activeCard);
            }

            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDragging);
        }

        function drag(e) {
            if (activeCard) {
                e.preventDefault();
                let newX = e.clientX - initialX;
                let newY = e.clientY - initialY;

                newX += canvas.scrollLeft;
                newY += canvas.scrollTop;

                const deltaX = newX - parseInt(activeCard.style.left);
                const deltaY = newY - parseInt(activeCard.style.top);

                selectedCards.forEach(card => {
                    const cardX = parseInt(card.style.left) + deltaX;
                    const cardY = parseInt(card.style.top) + deltaY;
                    card.style.left = `${cardX}px`;
                    card.style.top = `${cardY}px`;
                });
            }
        }

        function stopDragging() {
            activeCard = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDragging);
        }

        function deleteSelectedCards() {
            selectedCards.forEach(card => {
                canvas.removeChild(card);
            });
            selectedCards.clear();
        }

        function openBatchModal() {
            batchModal.style.display = 'block';
            batchInput.focus();
            isBatchModalOpen = true;
        }

        function closeBatchModal() {
            batchModal.style.display = 'none';
            batchInput.value = '';
            isBatchModalOpen = false;
        }

        function createBatchCards() {
            const tasks = batchInput.value.split('\n').filter(task => task.trim() !== '');
            tasks.forEach(task => {
                createNewCard(task.trim());
            });
            closeBatchModal();
        }

        function selectAllCards() {
            const allCards = document.querySelectorAll('.card');
            allCards.forEach(card => {
                card.classList.add('selected');
                selectedCards.add(card);
            });
        }

        function createHeader(text = '') {
            const canvasRect = canvas.getBoundingClientRect();
            const header = document.createElement('div');
            header.className = 'header';
            header.innerHTML = `
                <span class="delete-btn">&times;</span>
                <span class="header-text" contenteditable="false">Header</span>
            `;
            
            // Add header to canvas temporarily to get its dimensions
            header.style.visibility = 'hidden';
            canvas.appendChild(header);
            const headerRect = header.getBoundingClientRect();
            
            // Calculate centered position
            const x = lastMouseX - canvasRect.left + canvas.scrollLeft - (headerRect.width / 2);
            const y = lastMouseY - canvasRect.top + canvas.scrollTop - (headerRect.height / 2);
            
            // Make header visible and update its position
            header.style.visibility = 'visible';
            header.innerHTML = `
                <span class="delete-btn">&times;</span>
                <span class="header-text" contenteditable="false">Header</span>
            `;
            header.style.left = `${x}px`;
            header.style.top = `${y}px`;

            const deleteBtn = header.querySelector('.delete-btn');
            deleteBtn.addEventListener('click', () => {
                canvas.removeChild(header);
            });

            const headerText = header.querySelector('.header-text');
            headerText.addEventListener('dblclick', () => {
                headerText.contentEditable = true;
                headerText.focus();
            });

            headerText.addEventListener('blur', () => {
                headerText.contentEditable = false;
            });

            header.addEventListener('mousedown', startDragging);
            canvas.appendChild(header);

            // Make the header text editable immediately
            if (text === '') {
                headerText.contentEditable = true;
                headerText.focus();
                // Select all text
                window.getSelection().selectAllChildren(headerText);
            }
        }

        // Track mouse position
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        canvas.addEventListener('mousemove', (e) => {
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        // Make canvas droppable for items from agenda
        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (draggedFromAgenda) {
                e.dataTransfer.dropEffect = 'move';
            }
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            if (draggedFromAgenda) {
                const canvasRect = canvas.getBoundingClientRect();
                const dropX = e.clientX - canvasRect.left + canvas.scrollLeft;
                const dropY = e.clientY - canvasRect.top + canvas.scrollTop;
                const cardText = draggedItem.querySelector('.card-text').textContent;
                const newCard = createCard(cardText, dropX - 100, dropY - 50);

                // Make sure the card is fully draggable, including to agenda slots
                makeDraggable();

                if (originalParent && draggedItem.parentNode) {
                    draggedItem.parentNode.removeChild(draggedItem);
                }
                draggedFromAgenda = false;
            }
        });
    </script>
</body>

</html>
